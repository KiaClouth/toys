class SmoothCorners {
  static get inputProperties() {
    return ['--smooth-corners']
  }

  paint(ctx, geom, properties) {
    // console.log(geom);
    // 将css属性中的--smooth-corners赋值给变量c
    const c = properties.get('--smooth-corners').toString()

    const n = c
    let m = n

    //限定区间
    if (n > 100) m = 100
    if (n < 0.00000000001) m = 0.00000000001

    const w = Math.trunc(geom.width / 2)
    const h = Math.trunc(geom.height / 2)

    //   将椭圆分成4个象限的四个部分
    const coordinate = [[], []]

    //   记录x,y正方向象限的坐标值
    for (let i = 0; i < w + 1; i++) {
      const x = i
      const y = Math.pow(Math.abs(Math.pow(h, m) * (1 - Math.pow(i, m) / Math.pow(w, m))), 1 / m) + h
      coordinate[0].push(x)
      coordinate[1].push(y)
    }

    //开始绘制
    ctx.beginPath()

    // 绘制第一象限，并镜像绘制其余三个象限
    for (let i = 0; i < coordinate[0].length; i++) {
      if (i == 0) {
        ctx.moveTo(w, h)
        ctx.lineTo(w, 2 * h)
      } else ctx.lineTo(w + coordinate[0][i], +coordinate[1][i])
    }
    for (let i = 0; i < coordinate[0].length; i++) {
      if (i == 0) {
        ctx.moveTo(w, h)
        ctx.lineTo(w, 0)
      } else ctx.lineTo(w + coordinate[0][i], -coordinate[1][i] + 2 * h)
    }
    for (let i = 0; i < coordinate[0].length; i++) {
      if (i == 0) {
        ctx.moveTo(w, h)
        ctx.lineTo(w, 2 * h)
      } else ctx.lineTo(w - coordinate[0][i], +coordinate[1][i])
    }
    for (let i = 0; i < coordinate[0].length; i++) {
      if (i == 0) {
        ctx.moveTo(w, h)
        ctx.lineTo(w, 0)
      } else ctx.lineTo(w - coordinate[0][i], -coordinate[1][i] + 2 * h)
    }

    ctx.closePath()
    ctx.fill()
  }
}

registerPaint('smooth-corners', SmoothCorners)

// /*
//  * This file is autogenerated.
//  * houdini-leaf.js
//  * https://github.com/zhenyanghua/houdini/tree/master/leaf
//  */

// if ('registerProperty' in CSS) {
//   CSS.registerProperty({
//     name: '--leaf-size',
//     syntax: '<number>',
//     inherits: false,
//     initialValue: 16
//   });

//   CSS.registerProperty({
//     name: '--leaf-color',
//     syntax: '<color>',
//     inherits: true,
//     initialValue: '#73ce8f'
//   });

//   CSS.registerProperty({
//     name: '--leaf-variance',
//     syntax: 'left | around',
//     inherits: false,
//     initialValue: 'left'
//   });
// }

// const randomInt = (max) => Math.floor(Math.random() * Math.floor(max));

// class LeafPainter {
//   static get inputProperties() {
//     return [
//       '--leaf-size',
//       '--leaf-color',
//       '--leaf-variance'
//     ];
//   }

//   get leafSize() {
//     return this._leafSize;
//   }

//   set leafSize(size) {
//     this._leafSize = size;
//   }

//   get leafColor() {
//     return this._leafColor;
//   }

//   set leafColor(color) {
//     this._leafColor = color;
//   }

//   get leafVariance() {
//     return this._leafVariance;
//   }

//   set leafVariance(variance) {
//     this._leafVariance = variance;
//   }

//   /**
//    * The starting point of the vine in the canvas
//    * @return {number}
//    */
//   get x() {
//     return this.leafSize * 2;
//   }

//   /**
//    * The distance between the border the vine grow along and the other side of the vine.
//    * @return {number}
//    */
//   get width() {
//     return this.x + this.leafSize * 2;
//   }

//   /**
//    * vine directions
//    * v>>>>>>^
//    * v      ^
//    * v      ^
//    * v<<<<<<^
//    */
//   paint(ctx, geom, properties) {
//     this.leafSize = parseInt(properties.get('--leaf-size')) || 16;
//     this.leafColor = (properties.get('--leaf-color') || '#73ce8f').toString().trim();
//     this.leafVariance = (properties.get('--leaf-variance') || 'left').toString().trim();

//     // left
//     this.paintVine(ctx, properties, geom.height, 0, [0, 0]);

//     if (this.leafVariance === 'around') {
//       // top
//       this.paintVine(ctx, properties, geom.width, -90, [-this.width, 0]);
//       // // right
//       this.paintVine(ctx, properties, geom.height, -180, [-geom.width, -geom.height]);
//       // // bottom
//       this.paintVine(ctx, properties, geom.width, -270, [geom.height - this.width, -geom.width]);
//     }
//   }

//   leaf(ctx, x, y, size, dir) {
//     ctx.save();
//     ctx.translate(x, y);
//     ctx.scale(size, size);
//     ctx.beginPath();
//     ctx.moveTo(dir, -0.7);
//     ctx.bezierCurveTo(dir, -0.7, 0.4 * dir, -1, 0, 0);
//     ctx.bezierCurveTo(0, 0, dir, 0.4, dir, -0.7);
//     ctx.fill();
//     ctx.restore();
//   }

//   vine(ctx, x, numLeaves, leafSize, length, angle) {
//     const isAround = this.leafVariance === 'around';

//     ctx.beginPath();
//     ctx.moveTo(x, isAround ? x + leafSize : 0);
//     if (isAround && (Math.abs(angle) === 90 || Math.abs(angle) === 270)) { // top or bottom
//       ctx.quadraticCurveTo(x, x, x - leafSize, x);
//       ctx.moveTo(x, x + leafSize);
//     }
//     ctx.lineTo(x, isAround ? length - x - leafSize : length);
//     if (isAround && (angle === 0 || Math.abs(angle) === 180)) { // left or right
//       ctx.quadraticCurveTo(x, length - x, x + leafSize, length - x);
//     }
//     ctx.stroke();
//     const gap = length / numLeaves;
//     let direction = 1;
//     for (let i = 0; i < numLeaves; i++) {
//       const r = randomInt(gap);
//       const y = gap * i + r;
//       if (!isAround || (isAround && y > x && y < length - x)) {
//         this.leaf(ctx, x, y, leafSize, direction);
//         direction = -direction;
//       }
//     }
//   }

//   paintVine(ctx, properties, length, angle, origin) {
//     const numLeaves = Math.floor(length / this.leafSize) * 1.5;

//     ctx.strokeStyle = ctx.fillStyle = this.leafColor;

//     ctx.save();
//     ctx.rotate(angle * Math.PI / 180);
//     ctx.translate(...origin);
//     this.vine(ctx, this.x, numLeaves, this.leafSize, length, angle);
//     ctx.restore();
//   }

// }

// registerPaint('leaf', LeafPainter);

// (() => { const worklet = ``;

// const workletBlob = URL.createObjectURL(new Blob([worklet], { type: 'application/javascript' }));

// window.CSS.paintWorklet.addModule(workletBlob);
// })();
